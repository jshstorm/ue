// Copyright 2017 CLOVERGAMES Co., Ltd. All Rights Reserved.


#include "AnuDatatableBlueprintLibrary.h"
#include "Engine/DataTable.h"
#include "Subsystems/AssetEditorSubsystem.h"
#include "Kismet/GameplayStatics.h"

#include "Manager/ReferenceManager.h"
#include "Components/AnuStaticMeshComponent.h"
#include "Reference_Resource.h"
#include "Reference_Interactor.h"
#include "Factories/FbxSkeletalMeshImportData.h"
#include "Actor/SubLevelVisibleTriggerVolume.h"
#include "Actor/SubLevelController.h"

#include "UnrealED/Public/FileHelpers.h"

#include "Pawns/ANU_Monster.h"
#include "Pawns/ANU_NPC.h"

void UAnuDatatableBlueprintLibrary::ExportMapPreview(UDataTable* dataTable, TArray<TSoftObjectPtr<UTexture2D>> ignoreTextures)
{
	UDataTable* worldTable = LoadObject<UDataTable>(nullptr, TEXT("/Game/Anu/DataTable/References/Resource/DT_ResourceWorld.DT_ResourceWorld"));
	UAssetEditorSubsystem* assetSubSystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>();

	REFERENCE_MGR->InitializeReferenceManager();

	TArray<URefStageInfo*> stages;
	REFERENCE_MGR->DoRefIterationJob<URefStageInfo>([&stages](URefStageInfo* reference) {
		stages.Emplace(reference);
	});

	for (int32 i = 0; i < stages.Num(); ++i) {
		auto stage = stages[i];
		if (stage->_region == nullptr) {
			UE_LOG(LogTemp, Error, TEXT("[ExportMapPreview] Invalid region detected - stage[%s], region:[%s]"), *stage->UID.ToString(), *stage->Region.ToString());
			continue;
		}

		if (stage->_region->_world == nullptr) {
			UE_LOG(LogTemp, Error, TEXT("[ExportMapPreview] Invalid world detected - stage[%s], world:[%s]"), *stage->UID.ToString(), *stage->_region->WorldUID.ToString());
			continue;
		}

		auto worldInfo = worldTable->FindRow<FAnuResourceModelWorld>(stage->_region->Model, "");
		if (worldInfo == nullptr) {
			continue;
		}

		auto previewData = dataTable->FindRow<FAnuResourceMapPreview>(stage->UID, "");
		if (previewData && previewData->AutoGenerated == false) {
			continue;
		}

		UObject* worldObj = worldInfo->World.LoadSynchronous();
		assetSubSystem->OpenEditorForAsset(worldObj, EToolkitMode::Standalone, nullptr);

		TArray<AActor*> actors;
		UGameplayStatics::GetAllActorsOfClass(GWorld, ARefMonInteractor::StaticClass(), actors);
		if (actors.Num() == 0) {
			continue;
		}

		FAnuResourceMapPreview mapInfo;
		for (AActor* actor : actors) {
			ARefMonInteractor* monInteractor = Cast<ARefMonInteractor>(actor);
			URefObject* refObject = REFERENCE_MGR->GetRefObj<URefObject>(monInteractor->SpawnObject_UID);
			if (refObject == nullptr) {
				continue;
			}

			UTexture2D* icon = refObject->GetIconTexture();
			if (ignoreTextures.Contains(icon)) {
				continue;
			}

			FText& name = monInteractor->Grade == ECharacterGrade::Boss ? mapInfo.BossMonsterIcons.FindOrAdd(icon) : mapInfo.MonsterIcons.FindOrAdd(icon);
			name = refObject->GetName();
		}

		if (mapInfo.BossMonsterIcons.Num() == 0 && mapInfo.MonsterIcons.Num() == 0) {
			continue;
		}

		dataTable->RemoveRow(stage->UID);
		dataTable->AddRow(stage->UID, mapInfo);
	}

	assetSubSystem->OpenEditorForAsset(TEXT("/Game/Editor/Map/EditorStarter.EditorStarter"));
	assetSubSystem->OpenEditorForAsset(dataTable);
}

void UAnuDatatableBlueprintLibrary::BuildVisibleActors(TSoftObjectPtr<UWorld> triggerLevel, FString skipLevelWord, bool resetTable)
{
	UAssetEditorSubsystem* assetSubSystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>();
	UWorld* triggerWorldObj = triggerLevel.LoadSynchronous();
	assetSubSystem->OpenEditorForAsset(triggerWorldObj, EToolkitMode::Standalone, nullptr);

	TArray<AActor*> actors;
	UGameplayStatics::GetAllActorsOfClass(GWorld, ASubLevelVisibleTriggerVolume::StaticClass(), actors);

	TMap<FString, TArray<TSoftObjectPtr<UWorld>>> mapInfos;
	TMap<FString, TArray<TSoftObjectPtr<UWorld>>> nightMapInfos;
	TMap<FString, FStreamingLoadAssetData> assteInfos;

	for (AActor* actor : actors) {
		ASubLevelVisibleTriggerVolume* visibleVolumn = Cast<ASubLevelVisibleTriggerVolume>(actor);
		if (visibleVolumn == nullptr) {
			continue;
		}

		TArray<TSoftObjectPtr<UWorld>> levels = *visibleVolumn->GetSublevels();
		TArray<TSoftObjectPtr<UWorld>> nightLevels = *visibleVolumn->GetNightSublevels();
		FString actorPath = actor->GetPathName();
		if (levels.Num() > 0) {
			mapInfos.Emplace(actorPath, levels);
		}
		if (nightLevels.Num() > 0) {
			nightMapInfos.Emplace(actorPath, nightLevels);
		}
	}

	UDataTable* workTable = LoadObject<UDataTable>(nullptr, TEXT("/Game/Anu/DataTable/Level/DT_StreamLoadAsset.DT_StreamLoadAsset"));
	workTable->EmptyTable();

	for (auto pair : mapInfos) {
		for (TSoftObjectPtr<UWorld> level : pair.Value) {
			if (assteInfos.Contains(level.GetAssetName()) == true) {
				continue;
			}

			if (skipLevelWord != "" && level.GetAssetName().Contains(skipLevelWord)) {
				continue;
			}

			UWorld* worldObj = level.LoadSynchronous();
			assetSubSystem->OpenEditorForAsset(worldObj, EToolkitMode::Standalone, nullptr);
			UGameplayStatics::GetAllActorsOfClass(GWorld, AActor::StaticClass(), actors);

			FStreamingLoadAssetData& assetInfo = assteInfos.FindOrAdd(level.GetAssetName());
			assetInfo.type = EStreamLoadType::Normal;
			for (AActor* actor : actors) {
				if (UParticleSystemComponent* paComponent = actor->GetComponentAs<UParticleSystemComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = paComponent->Template->GetPathName();
					info.transform = actor->GetTransform();
					info.mobility = paComponent->Mobility;
					info.collisionProfileName = paComponent->GetCollisionProfileName();
					info.drawCulldistance = paComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = paComponent->bAllowCullDistanceVolume;
					assetInfo.paAssetInfos.Add(info);
				}
				else if (UStaticMeshComponent* stComponent = actor->GetComponentAs<UStaticMeshComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = stComponent->GetStaticMesh()->GetPathName();
					info.transform = actor->GetTransform();
					info.mobility = stComponent->Mobility;
					info.collisionProfileName = stComponent->GetCollisionProfileName();
					info.drawCulldistance = stComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = stComponent->bAllowCullDistanceVolume;
					for (int i = 0; i < stComponent->GetNumMaterials(); i++) {
						UMaterialInterface* sourceMaterial = stComponent->GetMaterial(i);
						FSoftObjectPath path(sourceMaterial->GetPathName());
						info.materials.Add(i, path);
					}
					assetInfo.stAssetInfos.Add(info);
				}
				else if (USkeletalMeshComponent* skComponent = actor->GetComponentAs<USkeletalMeshComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = skComponent->SkeletalMesh->GetPathName();
					//info.animClass = skComponent->GetAnimClass();
					info.transform = actor->GetTransform();
					info.mobility = skComponent->Mobility;
					info.collisionProfileName = skComponent->GetCollisionProfileName();
					info.drawCulldistance = skComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = skComponent->bAllowCullDistanceVolume;
					assetInfo.skAssetInfos.Add(info);
				}
				else {
					continue;
				}

			}

			if (assetInfo.stAssetInfos.Num() == 0 && assetInfo.skAssetInfos.Num() == 0 && assetInfo.paAssetInfos.Num() == 0) {
				assteInfos.Remove(level.GetAssetName());
				continue;
			}
			workTable->AddRow(FName(level.GetAssetName()), assetInfo);
		}
	}

	for (auto pair : nightMapInfos) {
		for (TSoftObjectPtr<UWorld> level : pair.Value) {
			if (assteInfos.Contains(level.GetAssetName()) == true) {
				continue;
			}

			if (skipLevelWord != "" && level.GetAssetName().Contains(skipLevelWord)) {
				continue;
			}

			UWorld* worldObj = level.LoadSynchronous();
			assetSubSystem->OpenEditorForAsset(worldObj, EToolkitMode::Standalone, nullptr);
			UGameplayStatics::GetAllActorsOfClass(GWorld, AActor::StaticClass(), actors);

			FStreamingLoadAssetData& assetInfo = assteInfos.FindOrAdd(level.GetAssetName());
			assetInfo.type = EStreamLoadType::Night;
			for (AActor* actor : actors) {
				if (UStaticMeshComponent* stComponent = actor->GetComponentAs<UStaticMeshComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = stComponent->GetStaticMesh()->GetPathName();
					info.transform = actor->GetTransform();
					info.mobility = stComponent->Mobility;
					info.collisionProfileName = stComponent->GetCollisionProfileName();
					info.drawCulldistance = stComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = stComponent->bAllowCullDistanceVolume;
					for (int i = 0; i < stComponent->GetNumMaterials(); i++) {
						UMaterialInterface* sourceMaterial = stComponent->GetMaterial(i);
						UMaterial* mat = sourceMaterial->GetMaterial();
						if (mat != stComponent->GetStaticMesh()->GetMaterial(i)->GetMaterial()) {
							FSoftObjectPath path(mat->GetPathName());
							info.materials.Add(i, path);
						}
					}
					assetInfo.stAssetInfos.Add(info);

				}
				else if (USkeletalMeshComponent* skComponent = actor->GetComponentAs<USkeletalMeshComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = skComponent->SkeletalMesh->GetPathName();
					//info.animClass = skComponent->GetAnimClass();
					info.transform = actor->GetTransform();
					info.mobility = skComponent->Mobility;
					info.collisionProfileName = skComponent->GetCollisionProfileName();
					info.drawCulldistance = skComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = skComponent->bAllowCullDistanceVolume;
					assetInfo.skAssetInfos.Add(info);
				}
				else if (UParticleSystemComponent* paComponent = actor->GetComponentAs<UParticleSystemComponent>()) {
					FStreamingLoadAssetInfo info;
					info.asset = paComponent->Template->GetPathName();
					info.transform = actor->GetTransform();
					info.mobility = paComponent->Mobility;
					info.collisionProfileName = paComponent->GetCollisionProfileName();
					info.drawCulldistance = paComponent->LDMaxDrawDistance;
					info.allowCullDistanceVolume = paComponent->bAllowCullDistanceVolume;
					assetInfo.paAssetInfos.Add(info);
				}
				else {
					continue;
				}
			}

			if (assetInfo.stAssetInfos.Num() == 0 && assetInfo.skAssetInfos.Num() == 0 && assetInfo.paAssetInfos.Num() == 0) {
				assteInfos.Remove(level.GetAssetName());
				continue;
			}
			workTable->AddRow(FName(level.GetAssetName()), assetInfo);
		}
	}
}

void UAnuDatatableBlueprintLibrary::BuildVisibleActorsV2(TSoftObjectPtr<UWorld> triggerLevel, TSoftObjectPtr<UWorld> subLevel, FString skipLevelWord, bool resetTable)
{
	UAssetEditorSubsystem* assetSubSystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>();
	UWorld* triggerWorldObj = triggerLevel.LoadSynchronous();
	assetSubSystem->OpenEditorForAsset(triggerWorldObj, EToolkitMode::Standalone, nullptr);

	TArray<AActor*> actors;
	UGameplayStatics::GetAllActorsOfClass(GWorld, ASubLevelVisibleTriggerVolume::StaticClass(), actors);
	
	TSet<FString> mapNames;
	TSet<FString> nightMapNames;
	
	TMap<FString, FStreamingLoadAssetData> assteInfos;

	for (AActor* actor : actors) {
		ASubLevelVisibleTriggerVolume* visibleVolumn = Cast<ASubLevelVisibleTriggerVolume>(actor);
		if (visibleVolumn == nullptr) {
			continue;
		}

		for (TSoftObjectPtr<UWorld> levelPath : *visibleVolumn->GetSublevels()) {
			mapNames.Emplace(levelPath.GetAssetName());
		}

		for (TSoftObjectPtr<UWorld> levelPath : *visibleVolumn->GetNightSublevels()) {
			nightMapNames.Emplace(levelPath.GetAssetName());
		}
	}

	UDataTable* workTable = LoadObject<UDataTable>(nullptr, TEXT("/Game/Anu/DataTable/Level/DT_StreamLoadAsset.DT_StreamLoadAsset"));
	if (resetTable == true) {
		workTable->EmptyTable();
	}

	UWorld* subWorldObj = subLevel.LoadSynchronous();
	assetSubSystem->OpenEditorForAsset(subWorldObj, EToolkitMode::Standalone, nullptr);
	UGameplayStatics::GetAllActorsOfClass(GWorld, AActor::StaticClass(), actors);

	for (AActor* actor : actors) {
		FString levelName = actor->GetLevel()->GetOuter()->GetName();
		FStreamingLoadAssetData& assetInfo = assteInfos.FindOrAdd(levelName);

		if (mapNames.Contains(levelName)) {
			assetInfo.type = EStreamLoadType::Normal;
		}
		else if (nightMapNames.Contains(levelName)) {
			assetInfo.type = EStreamLoadType::Night;
		}
		else {
			continue;
		}
		if (UParticleSystemComponent* paComponent = actor->GetComponentAs<UParticleSystemComponent>()) {
			FStreamingLoadAssetInfo info;
			info.asset = paComponent->Template->GetPathName();
			info.transform = actor->GetTransform();
			info.mobility = paComponent->Mobility;
			info.collisionProfileName = paComponent->GetCollisionProfileName();
			info.drawCulldistance = paComponent->LDMaxDrawDistance;
			info.allowCullDistanceVolume = paComponent->bAllowCullDistanceVolume;
			assetInfo.paAssetInfos.Add(info);
		}
		else if (UStaticMeshComponent* stComponent = actor->GetComponentAs<UStaticMeshComponent>()) {
			FStreamingLoadAssetInfo info;
			info.asset = stComponent->GetStaticMesh()->GetPathName();
			info.transform = actor->GetTransform();
			info.mobility = stComponent->Mobility;
			info.collisionProfileName = stComponent->GetCollisionProfileName();
			info.drawCulldistance = stComponent->LDMaxDrawDistance;
			info.allowCullDistanceVolume = stComponent->bAllowCullDistanceVolume;
			for (int i = 0; i < stComponent->GetNumMaterials(); i++) {
				UMaterialInterface* sourceMaterial = stComponent->GetMaterial(i);
				FSoftObjectPath path(sourceMaterial->GetPathName());
				info.materials.Add(i, path);
			}
			assetInfo.stAssetInfos.Add(info);
		}
		else if (USkeletalMeshComponent* skComponent = actor->GetComponentAs<USkeletalMeshComponent>()) {
			FStreamingLoadAssetInfo info;
			info.asset = skComponent->SkeletalMesh->GetPathName();
			//info.animClass = skComponent->GetAnimClass();
			info.transform = actor->GetTransform();
			info.mobility = skComponent->Mobility;
			info.collisionProfileName = skComponent->GetCollisionProfileName();
			info.drawCulldistance = skComponent->LDMaxDrawDistance;
			info.allowCullDistanceVolume = skComponent->bAllowCullDistanceVolume;
			assetInfo.skAssetInfos.Add(info);
		}
		else {
			continue;
		}
	}

	for (auto& assetInfo : assteInfos) {
		if (assetInfo.Value.stAssetInfos.Num() == 0 && assetInfo.Value.skAssetInfos.Num() == 0 && assetInfo.Value.paAssetInfos.Num() == 0) {
			continue;
		}
		workTable->AddRow(FName(assetInfo.Key), assetInfo.Value);
	}
}

void UAnuDatatableBlueprintLibrary::LoadEditorLevel(TSoftObjectPtr<UWorld> level)
{
	UAssetEditorSubsystem* assetSubSystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>();
	UWorld* world = level.LoadSynchronous();
	assetSubSystem->OpenEditorForAsset(world, EToolkitMode::Standalone, nullptr);
}
